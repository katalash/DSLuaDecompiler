using System;
using System.Collections.Generic;
using LuaDecompilerCore.CFG;
using LuaDecompilerCore.Utilities;

namespace LuaDecompilerCore.IR
{
    public abstract class ConditionalJumpBase : Instruction
    {
        public Expression Condition { get; set; }
        
        protected ConditionalJumpBase(Expression condition)
        {
            Condition = condition;
        }
        
        public override void Parenthesize()
        {
            Condition.Parenthesize();
        }

        public override HashSet<Identifier> GetUsedRegisters(HashSet<Identifier> uses)
        {
            Condition.GetUsedRegisters(uses);
            return uses;
        }
        
        public override Interval GetTemporaryRegisterRange()
        {
            var temporaries = new Interval();
            temporaries.AddToTemporaryRegisterRange(Condition.GetOriginalUseRegisters());
            temporaries.MergeTemporaryRegisterRange(Condition.GetTemporaryRegisterRange());
            return temporaries;
        }

        public override void RenameUses(Identifier original, Identifier newIdentifier)
        {
            Condition.RenameUses(original, newIdentifier);
        }

        public override bool ReplaceUses(Identifier orig, Expression sub)
        {
            if (Expression.ShouldReplace(orig, Condition))
            {
                Condition = sub;
                return true;
            }
            return Condition.ReplaceUses(orig, sub);
        }

        public override int UseCount(Identifier use)
        {
            return Condition.UseCount(use);
        }

        public override List<Expression> GetExpressions()
        {
            return Condition.GetExpressions();
        }

        public override void IterateUses(Action<IIrNode, UseType, IdentifierReference> function)
        {
            IterateUsesSuccessor(Condition, UseType.ExpressionLeft, function);
        }
    }

    /// <summary>
    /// Convenience interface for all jumps to labels
    /// </summary>
    public interface IJumpLabel
    {
        public Label Destination { get; set; }
    }

    /// <summary>
    /// Convenience interface for all jumps to blocks
    /// </summary>
    public interface IJump
    {
        public BasicBlock Destination { get; set; }
    }

    /// <summary>
    /// Unconditional jump to a label
    /// </summary>
    public sealed class JumpLabel : Instruction, IJumpLabel
    {
        /// <summary>
        /// The destination label for the jump
        /// </summary>
        public Label Destination { get; set; }
        
        public JumpLabel(Label destination)
        {
            Destination = destination;
        }

        public override bool MatchAny(Func<IIrNode, bool> condition)
        {
            var result = condition.Invoke(this);
            result = result || Destination.MatchAny(condition);
            return result;
        }
    }

    /// <summary>
    /// Unconditional jump to a block
    /// </summary>
    public sealed class Jump : Instruction, IJump
    {
        /// <summary>
        /// The destination block for the jump. Typically used for printing.
        /// </summary>
        public BasicBlock Destination { get; set; }

        public Jump(BasicBlock destination)
        {
            Destination = destination;
        }
    }

    /// <summary>
    /// Conditional jump to a label
    /// </summary>
    public sealed class ConditionalJumpLabel : ConditionalJumpBase, IJumpLabel
    {
        /// <summary>
        /// The destination label for the jump
        /// </summary>
        public Label Destination { get; set; }
        
        /// <summary>
        /// Lua 5.1+ and HKS may have a post-jump assignment that is executed after the jump is taken.
        /// This assignment needs to be added to the successor block once conversion to control flow graph
        /// is done.
        /// </summary>
        public readonly Assignment? PostTakenAssignment;

        /// <summary>
        /// Local variables that are always killed upon entering dominance successors of this block regardless if they
        /// are still "in scope" or not. Used to make sure loop local variables properly go out of scope since they
        /// are often generated by the compiler before the loop scope officially begins.
        /// </summary>
        public readonly Interval KilledLocals;

        public ConditionalJumpLabel(
            Label destination, 
            Expression condition, 
            Assignment? postTakenAssignment = null,
            Interval killedLocals = default) : 
            base(condition)
        {
            Destination = destination;
            PostTakenAssignment = postTakenAssignment;
            if (Condition is BinOp op)
            {
                op.NegateCondition();
            }

            KilledLocals = killedLocals;
        }

        public override bool MatchAny(Func<IIrNode, bool> condition)
        {
            var result = condition.Invoke(this);
            result = result || Condition.MatchAny(condition);
            result = result || Destination.MatchAny(condition);
            return result;
        }
    }

    /// <summary>
    /// Conditional jump to a block
    /// </summary>
    public sealed class ConditionalJump : ConditionalJumpBase, IJump
    {
        /// <summary>
        /// The destination block for the jump. Typically used for printing.
        /// </summary>
        public BasicBlock Destination { get; set; }
        
        public ConditionalJump(BasicBlock destination, Expression condition) : 
            base(condition)
        {
            Destination = destination;
        }
        
        public override bool MatchAny(Func<IIrNode, bool> condition)
        {
            var result = condition.Invoke(this);
            result = result || Condition.MatchAny(condition);
            return result;
        }
    }
}
